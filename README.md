Haskell + nixpkgs = nix-hs
==========================

Are you a [Haskell][] programmer?  Do you use [nixpkgs][]?  Want to
make using those two together really simple?  You're in luck.

This project provides a Nix file that makes working with
Haskell projects very simple.  What does it do for you?  Well, here
are just a few of the things you'll love:

  * `cabal2nix` is automatically called when your Cabal file changes
  * Your package can be built with `nix-build`
  * Interactive development environment via `nix-shell`
  * Easily use any version of GHC in `nixpkgs`
  * Works with [direnv][]

Geting Started
--------------

Create a `default.nix` file that looks something like this:

```nix
{ pkgs ? import <nixpkgs> {}
}:

let
  nix-hs-src = fetchGit {
    url = "https://github.com/pjones/nix-hs.git";
    rev = "2003332a1e8e518b54e6143f9a9467a8a05abca4";
  };

  nix-hs = import "${nix-hs-src}/default.nix" { inherit pkgs; };

in nix-hs {
  cabal = ./mypackage.cabal;
}
```

And a `shell.nix` that looks like this:

```nix
# Load an interactive environment:
(import ./. {}).interactive
```

That's it!  Now `nix-build` and `nix-shell` just work!

Configuration
-------------

In addition to the `cabal` argument to the `nix-hs` function, there
are other ways to control how your package is built.

### Enable Flags from the Cabal File ###

If you have a flag defined in your package's cabal file you can enable
it using the `flags` argument:

```nix
nix-hs {
  cabal = ./mypackage.cabal;
  flags = [ "someflagname" ];
}
```

### Using a Broken Package ###

If one of your package's dependencies can't be built you can try
overriding it:

```nix
nix-hs {
  cabal = ./mypackage.cabal;

  overrides = lib: self: super: with lib; {
    pipes-text = unBreak (dontCheck (doJailbreak super.pipes-text));
  };
}
```

Integrating Your Text Editor and Shell
--------------------------------------

The best way to let your text editor and shell use the environment
created from Nix is to use [direnv][].  Here's an example `.envrc`
file:

```sh
# -*- sh -*-

# Load an environment from Nix:
use nix

# Reload if these files change:
watch_file mypackage.cabal
```

**NOTE:** Make sure you have a `shell.nix` file that exposes the
`interactive` attribute of the derivation, like the example above.

Access to Static Binaries
-------------------------

The derivation generated by the `nix-hs` function makes it easy to
access a "binary only" derivation.  This is perfect for deployments or
Docker containers where you don't want to bring along all of your
package's dependencies (including GHC).

The `bin` attribute of the derivation gives you access to this binary
only derivation.  For example, to create a docker container:

```nix
{ pkgs ? import <nixpkgs> { }
}:

let
  zxcvbn-ws = (import ./. { inherit pkgs; }).bin;

in pkgs.dockerTools.buildImage {
  name = "zxcvbn-ws";
  tag  = "latest";

  config = {
    Cmd = [ "${zxcvbn-ws}/bin/zxcvbn-ws" ];
  };
}
```

[haskell]: https://www.haskell.org/
[nixpkgs]: https://nixos.org/nix/
[direnv]: https://github.com/direnv/direnv
